### Imports ###
import os
import pytest
import yaml

import pandas as pd

from pathlib import Path
from typing import Tuple

### Fixtures ###
# Core config fixture
from sponge.config_manager import ConfigManager

@pytest.fixture
def core_config():
    return ConfigManager()

# TODO: Add new tests
### Unit tests ###
# Data retrieval functions
import sponge.modules.utils.data_retrieval as data_f

@pytest.mark.network
@pytest.mark.parametrize('input, compare_to', [
    (('https://raw.githubusercontent.com/kuijjerlab/sponge/main/LICENSE',
        'LICENSE'), 'LICENSE'),
    (('https://raw.githubusercontent.com/kuijjerlab/sponge/main/LICENSE',
        None), 'LICENSE'),
])
def test_download_with_progress(input, compare_to, tmp_path):
    if input[1] == None:
        data = data_f.download_with_progress(*input).read().decode()
    else:
        file_path = os.path.join(tmp_path, input[1])
        data_f.download_with_progress(input[0], file_path)
        data = open(file_path, 'r').read()

    comp_data = open(compare_to, 'r').read()

    assert data == comp_data


@pytest.mark.parametrize('input', [
    ['test_dataset', ['field1', 'field2', 'field3']],
    ['test_dataset', []],
])
def test_create_xml_query(input):
    xml_query = data_f.create_xml_query(*input)

    assert xml_query[:38].lower() == "<?xml version='1.0' encoding='utf-8'?>"
    assert xml_query.count('Attribute') == len(input[1])


@pytest.mark.network
@pytest.mark.parametrize('input', [
    ['hsapiens_gene_ensembl', ['ensembl_transcript_id', 'ensembl_gene_id']],
    ['hsapiens_gene_ensembl', ['ensembl_transcript_id']],
])
def test_retrieve_ensembl_data(input, core_config):
    input.append(core_config['url']['region']['xml'])
    df = pd.read_csv(data_f.retrieve_ensembl_data(*input), sep='\t')

    assert type(df) == pd.DataFrame
    assert len(df.columns) == len(input[1])


@pytest.mark.network
def test_get_ensembl_version(core_config):
    version_string = data_f.get_ensembl_version(
        core_config['url']['region']['rest'])
    split_version = version_string.split('.')

    assert len(split_version) == 2
    assert split_version[0] == 'GRCh38'


@pytest.mark.network
@pytest.mark.parametrize('input, expected_type', [
    ('hg38', pd.Series),
    ('random_assembly', type(None)),
    ('hg1992', type(None)),
])
def test_get_chromosome_mapping(input, expected_type, core_config):
    mapping = data_f.get_chromosome_mapping(input,
        core_config['url']['chrom_mapping'])

    assert type(mapping) == expected_type


# ConfigReader class


# VersionLogger class


# FileRetriever class


# TFBSRetriever class


# RegionRetriever class


# DataRetriever class


### Integration tests ###
from sponge.sponge import Sponge

def run_integration_test_common(
    tmp_path: Path,
    config_file: Path,
) -> Tuple[Path, Path]:
    """
    Run the common part of the integration tests, which includes
    modifying the output file paths to be in the temporary directory and
    checking they exist after running SPONGE.

    Parameters
    ----------
    tmp_path : Path
        Path to the temporary directory generated by pytest
    config_file : Path
        Path to the config file

    Returns
    -------
    Tuple[Path, Path]
        Paths to the generated motif and PPI priors
    """

    motif_output = os.path.join(tmp_path, 'motif_prior.tsv')
    ppi_output = os.path.join(tmp_path, 'ppi_prior.tsv')

    settings = yaml.safe_load(open(config_file, 'r'))
    settings['motif_output']['file_name'] = motif_output
    settings['ppi_output']['file_name'] = ppi_output
    test_config = os.path.join(tmp_path, 'user_config.yaml')
    yaml.safe_dump(settings, open(test_config, 'w', encoding='utf-8'))

    # Using the default user config file
    _ = Sponge(
        config_file=test_config,
        temp_folder=os.path.join(tmp_path, '.sponge_temp'),
    )

    assert os.path.exists(motif_output)
    assert os.path.exists(ppi_output)

    return (motif_output, ppi_output)


# The test is marked as slow because the download of the bigbed file takes
# a lot of time and the filtering is also time consuming unless parallelised
@pytest.mark.integration
@pytest.mark.network
@pytest.mark.slow
def test_full_default_workflow(tmp_path):
    _,_ = run_integration_test_common(
        tmp_path,
        # Default config file
        os.path.join('sponge', 'user_config.yaml'),
    )


@pytest.mark.integration
@pytest.mark.network
def test_small_workflow(tmp_path):
    motif_output,ppi_output = run_integration_test_common(
        tmp_path,
        os.path.join('tests', 'sponge', 'test_user_config.yaml'),
    )

    motif_df = pd.read_csv(motif_output, sep='\t', header=None)
    motif_df_t = pd.read_csv(os.path.join('tests', 'sponge',
        'test_motif_prior.tsv'), sep='\t', header=None)

    pd.testing.assert_frame_equal(motif_df, motif_df_t)

    ppi_df = pd.read_csv(ppi_output, sep='\t', header=None)
    ppi_df_t = pd.read_csv(os.path.join('tests', 'sponge',
        'test_ppi_prior.tsv'), sep='\t', header=None)

    pd.testing.assert_frame_equal(ppi_df, ppi_df_t)